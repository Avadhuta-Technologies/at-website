---
// Cart Utility Component for IndexedDB-based cart management
---

<script>
  // IndexedDB Cart Utility
  class CartUtility {
    constructor() {
      this.dbName = 'NovaPodCart';
      this.dbVersion = 1;
      this.storeName = 'cart';
      this.db = null;
      this.init();
    }

    async init() {
      try {
        await this.openDB();
        this.updateCartBadge();
        this.migrateFromLocalStorage();
      } catch (error) {
        console.error('Failed to initialize IndexedDB cart utility:', error);
        this.fallbackToLocalStorage();
      }
    }

    async openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, this.dbVersion);
        
        request.onerror = () => {
          console.error('IndexedDB error:', request.error);
          reject(request.error);
        };
        
        request.onsuccess = () => {
          this.db = request.result;
          resolve();
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(this.storeName)) {
            const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
            store.createIndex('type', 'type', { unique: false });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }

    async getCart() {
      try {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.get('cart');
          
          request.onsuccess = () => {
            const result = request.result;
            resolve(result?.items || []);
          };
          
          request.onerror = () => reject(request.error);
        });
      } catch (error) {
        console.error('Failed to get cart from IndexedDB:', error);
        return this.getCartFromLocalStorage();
      }
    }

    async saveCart(cart) {
      return new Promise((resolve, reject) => {
        const transaction = this.db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.put({ 
          id: 'cart', 
          items: cart,
          lastUpdated: Date.now()
        });
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async addItem(item) {
      try {
        const cart = await this.getCart();
        const existingItem = cart.find(i => i.id === item.id && i.type === item.type);
        
        if (existingItem) {
          existingItem.quantity += 1;
        } else {
          cart.push({ ...item, quantity: 1, timestamp: Date.now() });
        }
        
        await this.saveCart(cart);
        await this.updateCartBadge();
        this.showNotification('Item added to cart!');
      } catch (error) {
        console.error('Failed to add item to cart:', error);
      }
    }

    async removeItem(id, type) {
      try {
        const cart = await this.getCart();
        const filteredCart = cart.filter(item => !(item.id === id && item.type === type));
        await this.saveCart(filteredCart);
        await this.updateCartBadge();
        this.showNotification('Item removed from cart!');
      } catch (error) {
        console.error('Failed to remove item from cart:', error);
      }
    }

    async updateQuantity(id, type, quantity) {
      try {
        const cart = await this.getCart();
        const item = cart.find(i => i.id === id && i.type === type);
        
        if (item) {
          if (quantity <= 0) {
            await this.removeItem(id, type);
          } else {
            item.quantity = quantity;
            item.timestamp = Date.now();
            await this.saveCart(cart);
            await this.updateCartBadge();
          }
        }
      } catch (error) {
        console.error('Failed to update quantity:', error);
      }
    }

    async clearCart() {
      try {
        await this.saveCart([]);
        await this.updateCartBadge();
        this.showNotification('Cart cleared!');
      } catch (error) {
        console.error('Failed to clear cart:', error);
      }
    }

    async getCartCount() {
      try {
        const cart = await this.getCart();
        return cart.reduce((sum, item) => sum + item.quantity, 0);
      } catch (error) {
        console.error('Failed to get cart count:', error);
        return 0;
      }
    }

    async getCartTotal() {
      try {
        const cart = await this.getCart();
        return cart.reduce((total, item) => {
          const price = this.parsePrice(item.price);
          return total + (price * item.quantity);
        }, 0);
      } catch (error) {
        console.error('Failed to get cart total:', error);
        return 0;
      }
    }

    parsePrice(price) {
      if (typeof price === 'number') return price;
      if (typeof price === 'string') {
        const match = price.match(/[\d.]+/);
        return match ? parseFloat(match[0]) * 100000 : 0;
      }
      return 0;
    }

    formatPrice(amount) {
      if (amount >= 100000) {
        return `₹${(amount / 100000).toFixed(1)}L`;
      } else if (amount >= 1000) {
        return `₹${(amount / 1000).toFixed(0)}K`;
      }
      return `₹${amount.toFixed(0)}`;
    }

    async updateCartBadge() {
      try {
        const count = await this.getCartCount();
        const badges = document.querySelectorAll('.cart-badge');
        
        badges.forEach(badge => {
          badge.textContent = count;
          badge.style.display = count > 0 ? 'flex' : 'none';
        });
      } catch (error) {
        console.error('Failed to update cart badge:', error);
      }
    }

    showNotification(message) {
      // Create notification element
      const notification = document.createElement('div');
      notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform transition-all duration-300 translate-x-full';
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.classList.remove('translate-x-full');
      }, 100);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => {
          if (document.body.contains(notification)) {
            document.body.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    async migrateFromLocalStorage() {
      try {
        const saved = localStorage.getItem('novapod-cart');
        if (saved) {
          const cart = JSON.parse(saved);
          const existingCart = await this.getCart();
          
          // Only migrate if IndexedDB is empty and localStorage has data
          if (existingCart.length === 0 && cart.length > 0) {
            await this.saveCart(cart);
            localStorage.removeItem('novapod-cart');
            console.log('Migrated cart data from localStorage to IndexedDB');
          }
        }
      } catch (error) {
        console.error('Failed to migrate from localStorage:', error);
      }
    }

    // Fallback methods
    fallbackToLocalStorage() {
      console.warn('Falling back to localStorage');
      this.getCart = this.getCartFromLocalStorage;
      this.saveCart = this.saveCartToLocalStorage;
    }

    getCartFromLocalStorage() {
      const saved = localStorage.getItem('novapod-cart');
      return Promise.resolve(saved ? JSON.parse(saved) : []);
    }

    saveCartToLocalStorage(cart) {
      localStorage.setItem('novapod-cart', JSON.stringify(cart));
      return Promise.resolve();
    }
  }

  // Initialize cart utility globally
  if (typeof window !== 'undefined') {
    window.cartUtility = new CartUtility();
  }
</script> 